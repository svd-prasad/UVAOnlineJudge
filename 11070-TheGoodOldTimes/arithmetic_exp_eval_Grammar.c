A/*****************************************************************************/
/*                                                                           */
/*  GRARIX - Graphical Evaluation of Arithmetic Expressions - Version 0.9    */
/*  2001 by Marc Pomplun, York University, Toronto, Canada                   */
/*                                                                           */
/*  This program evaluates arithmetic expressions consisting of floating     */
/*  point numbers, the operators +, -, *, and /, and parentheses.            */
/*                                                                           */
/*  It uses a three-state deterministic finite automaton to scan the input:  */
/*                                                                           */
/*  Transition Function:                      State                          */
/*                                                                           */
/*                         READ_ANYTHING   READ_NUMBER     READ_DECIMALS     */
/*         -------------------------------------------------------------     */
/*         +,-,*,/,(,)     READ_ANYTHING   READ_ANYTHING   READ_ANYTHING     */
/*         digit           READ_NUMBER     READ_NUMBER     READ_DECIMALS     */
/*  Input  decimal point   READ_NUMBER     READ_DECIMALS   ERROR             */
/*         space           READ_ANYTHING   READ_ANYTHING   READ_ANYTHING     */
/*         other           ERROR           ERROR           ERROR             */
/*                                                                           */
/*                                                                           */
/*  A recursive parser is used to evaluate the expression. This parser       */
/*  is based on the following context-free grammar:                          */
/*                                                                           */
/*  Expression -> Expression + Term | Expression - Term | Term               */
/*  Term       -> Term * Factor     | Term / Factor     | Factor             */
/*  Factor     -> ( Expression )    | - ( Expression )  | number | - number  */
/*                                                                           */
/*  Due to the left-recursive structure of this grammar, the parser reads    */
/*  the input from right to left.                                            */
/*                                                                           */
/*****************************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAXCHARACTERS 200    /* maximum number of characters in the input string */
#define MAXTERMINAL   100    /* maximum number of terminals */
#define MAXDIGIT       20    /* maximum number of digits in any number */
#define DIGITSSHOWN     5

#define READ_ANYTHING   0    /* the three states of the scanner DFA */
#define READ_NUMBER     1
#define READ_DECIMALS   2

struct structure {
  int row;
  int tcol, col1, col2, col3;
  char text[DIGITSSHOWN + 5];
} STRUCTURE;

int   column[MAXTERMINAL];
char  inputstring[MAXCHARACTERS];  /* input string containing the arithmetic expression */
int   terminal[MAXTERMINAL],       /* list of terminals generated by the scanner */
      terminal_position,           /* current reading/writing position in the list of terminals */
      subtree_position,
      last_terminal;
float terminal_value[MAXTERMINAL]; /* values of the numerical (N) terminals */
struct structure subtree[3*MAXTERMINAL];


void  scanString(char *);          /* function prototypes */
void  addSubtree(int, int, int, int, char *, float);
float evaluateExpression(int, int *);
float evaluateTerm(int, int *);
float evaluateFactor(int, int *);
int   alignedPosition(int, int);
int   alignSubtrees(void);
void  printTree(void);


void scanString(char *inputstring)    /* the scanner function - extracts list  */
{                                     /* of terminals from user's input string */
  int scanner_state = READ_ANYTHING,  /* the DFA's start state */
      reading_position = 0,           /* current reading position in the input string */
      number_position = 0,            /* current reading position in a number */
      current_character;              /* the last character read from the input string */
  char number[MAXDIGIT];

  terminal[0] = 'S';                  /* marking the start of the terminal list */
  terminal_position = 1;              /* first terminal will be stored in position 1 */

  while (reading_position < strlen(inputstring))  /* for all characters in the input string... */
  {
    current_character = inputstring[reading_position];  /* read character */

    switch (scanner_state)
    {
      case READ_ANYTHING:               /* read any character */
        if (strchr("0123456789.", current_character))
        {
          scanner_state = READ_NUMBER;  /* if digit or decimal point => read number */
          number_position = 0;          /* new number, so start at position 0 */
        }
        else if (strchr("()+-*/", current_character))
        {
          terminal[terminal_position++] = current_character;  /* store character if terminal */
          reading_position++;                /* advance reading position */
        }
        else if (current_character == ' ')   /* skip space characters */
          reading_position++;
        else
        {
          printf("Invalid character: %c\n", current_character);
          exit(1);
        }
        break;

      case READ_NUMBER:            /* read part of a number before the decimal point */
        if (strchr("0123456789.", current_character))
        {
          number[number_position++] = current_character;  /* if valid character, append to number string */
          reading_position++;
          if (current_character == '.')   /* if decimal point => read part of number after it */
            scanner_state = READ_DECIMALS;
        }
        else
        {
          number[number_position] = 0;    /* if other character, store number as 'N' terminal... */
          terminal[terminal_position] = 'N';
          terminal_value[terminal_position++] = atof(number);
          scanner_state = READ_ANYTHING;  /* ... and return to reading any characters */
        }
        break;

      case READ_DECIMALS:  /* read decimals, i.e. no further decimal points accepted */
        if (strchr("0123456789", current_character))
        {
          number[number_position++] = current_character;  /* append them to number string */
          reading_position++;
        }
        else
        {
          number[number_position] = 0;  /* store number if no further digits (see above) */
          terminal[terminal_position] = 'N';
          terminal_value[terminal_position++] = atof(number);
          scanner_state = READ_ANYTHING;
        }
    }
  }
    /* if input end is reached while reading a number, the number has to be stored */
  if (scanner_state == READ_NUMBER || scanner_state == READ_DECIMALS)
  {
    number[number_position] = 0;
    terminal[terminal_position] = 'N';
    terminal_value[terminal_position++] = atof(number);
  }
  last_terminal = terminal_position;
}


void addSubtree(int level, int p1, int p2, int p3, char *text, float value)
{                   /* add one subtree to the subtree list */
  char text2[50];

  subtree[subtree_position].row  = level;
  subtree[subtree_position].col1 = p1;
  subtree[subtree_position].col2 = p2;
  subtree[subtree_position].col3 = p3;
  if (p1 < 0)
    subtree[subtree_position].tcol = p3;
  else
    subtree[subtree_position].tcol = p2;
  if (p1 == -2 && strlen(text) != 0)
    strcpy(subtree[subtree_position].text, text);
  else
  {
    sprintf(text2, "%f", value);
    text2[5] = 0;
    if (text2[4] == '.')
      text2[4] = 0;
    sprintf(subtree[subtree_position].text, "%s%s", text, text2);
  }
  subtree_position++;
}


float evaluateExpression(int level, int *position)  /* parses and evaluates an expression starting at */
{                           /* the current reading position and extending to the left */
  float term_value, final_value;
  int p1, p2, p3;

  term_value = evaluateTerm(level + 1, &p3);  /* parse and evaluate Expression -> Term */
  if (terminal[terminal_position] == '+')  /* if followed by a '+' (to the left)... */
  {
    p2 = terminal_position;
    addSubtree(level + 1, -2, -2, p2, "+", 0.0);
    terminal_position--;    /* advance reading position to the left */
    final_value = evaluateExpression(level + 1, &p1) + term_value; /* Expression -> Expression + Term */
  }
  else if (terminal[terminal_position] == '-')  /* if followed by a '-' (to the left)... */
  {
    p2 = terminal_position;
    addSubtree(level + 1, -2, -2, p2, "-", 0.0);
    terminal_position--;
    final_value = evaluateExpression(level + 1, &p1) - term_value; /* Expression -> Expression - Term */
  }
  else
  {
    p1 = -1;
    final_value = term_value;
  }

  addSubtree(level, p1, p2, p3, "E:", final_value);

  if (p1 == -1)
    *position = p3;
  else
    *position = p2;
  return final_value;        /* return value of expression */
}


float evaluateTerm(int level, int *position)        /* parses and evaluates a term starting at */
{                           /* the current reading position (terminal_position) */
  float factor_value, final_value;
  int p1, p2, p3;

  factor_value = evaluateFactor(level + 1, &p3);         /* Term -> Factor */
  if (terminal[terminal_position] == '*')  /* if followed by a '*'... */
  {
    p2 = terminal_position;
    addSubtree(level + 1, -2, -2, p2, "*", 0.0);
    terminal_position--;
    final_value = evaluateTerm(level + 1, &p1) * factor_value;  /* Term -> Term * Factor */
  }
  else if (terminal[terminal_position] == '/')  /* if followed by a '/'... */
  {
    if (factor_value == 0.0)               /* check for division for zero... */
    {
      printf("Division by zero\n");
      exit(1);
    }
    p2 = terminal_position;
    addSubtree(level + 1, -2, -2, p2, "/", 0.0);
    terminal_position--;
    final_value = evaluateTerm(level + 1, &p1) / factor_value;  /* ... Term -> Term / Factor */
  }
  else
  {
    p1 = -1;
    final_value = factor_value;
  }

  addSubtree(level, p1, p2, p3, "T:", final_value);

  if (p1 == -1)
    *position = p3;
  else
    *position = p2;
  return final_value;                     /* return value of term */
}


float evaluateFactor(int level, int *position)      /* parses and evaluates a factor starting at */
{                           /* the current reading position (terminal_position) */
  float number_value;
  int p1, p2, p3;

  if (terminal[terminal_position] == 'N')        /* Factor -> <number> */
  {
    p3 = terminal_position;
    p1 = -1;
    number_value = terminal_value[terminal_position];
    terminal_position--;                         /* read number and advance reading position */
  }
  else if (terminal[terminal_position] == ')')   /* Factor -> ( Expression ) */
  {
    p3 = terminal_position;
    addSubtree(level + 1, -2, -2, p3, ")", 0.0);
    terminal_position--;
    number_value = evaluateExpression(level + 1, &p2);         /* evaluate expression left of the closed bracket... */
    if (terminal[terminal_position] == '(')      /* ... and check for an open bracket afterwards */
    {
      p1 = terminal_position;
      addSubtree(level + 1, -2, -2, p1, "(", 0.0);
      terminal_position--;
    }
    else
    {
      printf("Syntax error\n");                  /* open bracket is missing */
      exit(1);
    }
  }
  else                                           /* no other terminals that 'N' and ')' are allowed */
  {
    printf("Syntax error\n");
    exit(1);
  }
       /* Factor -> - Factor. Note: if followed by another factor, '-' is an operator, not a sign */
  if (terminal[terminal_position] == '-' &&
     (terminal[terminal_position - 1] != 'N' &&  /* symbol to the left of "-" is number? */
      terminal[terminal_position - 1] != ')'))   /* symbol to the left of "-" is (Expression) ? */
  {
    terminal[terminal_position] = 'M';
    terminal_value[terminal_position + 1] =- terminal_value[terminal_position + 1];
    terminal_position--;                         /* minus sign read */
    number_value = -number_value;                /* minus sign detected -> return negative value */
  }

  if (p1 == -1)
    addSubtree(level + 1, -2, -2, p3, "", terminal_value[p3]);

  addSubtree(level, p1, p2, p3, "F:", number_value);

  if (p1 == -1)
    *position = p3;
  else
    *position = p2;

  return number_value;                           /* otherwise, return positive value */
}


int alignedPosition(int col, int length)  /* calculate position of string within subtree */
{
  int newcol;

  newcol = column[col] - length/2;
  if (terminal[col] == 'N')
    newcol += (DIGITSSHOWN + 1)/2;
  return newcol;
}


int alignSubtrees()   /* calculate horizontal positions of all subtrees */
{
  int i, current_column = 1, maxrow = 0;

  for (i = 1; i < last_terminal; i++)
  {
    column[i] = current_column;
    if (terminal[i] == 'N')
      current_column += DIGITSSHOWN + 3;
    else if (terminal[i] != 'M')
      current_column += 2;
  }

  for (i = 0; i < subtree_position; i++)
  {
    if (subtree[i].col1 > 0)
    {
      subtree[i].col1 = alignedPosition(subtree[i].col1, 1);
      subtree[i].col2 = alignedPosition(subtree[i].col2, 1);
    }
    subtree[i].col3 = alignedPosition(subtree[i].col3, 1);
    subtree[i].tcol = alignedPosition(subtree[i].tcol, strlen(subtree[i].text));
    if (subtree[i].row > maxrow)
      maxrow = subtree[i].row;
  }
  return maxrow;
}


void printTree()     /* ASCII output of the derivation tree */
{
  int i, x, y, maxrow;
  char text[10];

  maxrow = alignSubtrees();

  printf("\n");
  for (y = 0; y <= 3*maxrow; y++)
  {
    for (x = 0; x < column[last_terminal - 1] + (DIGITSSHOWN + 4)/2; x++)
    {
      for (i = 0; i < subtree_position; i++)
      {
        if (3*subtree[i].row == y && subtree[i].tcol == x)
        {
          printf("%s", subtree[i].text);
          x += strlen(subtree[i].text);
        }
        else if (3*subtree[i].row + 1 == y)
        {
          if (subtree[i].col1 == x)
          {
            printf(",");
            x++;
            while (x < subtree[i].col2 - 1)
            {
              printf("%c", 151);
              x++;
            }
            printf("%c%c%c", 146, 124, 145);
            x += 3;
            while (x < subtree[i].col3)
            {
              printf("%c", 151);
              x++;
            }
            printf(".");
            x++;
          }
          else if (subtree[i].col1 == -1 && subtree[i].col3 == x)
          {
            printf("%c", 124);
            x++;
          }
        }
        else if (3*subtree[i].row + 2 == y)
        {
          if (subtree[i].col1 == x)
          {
            printf("%c", 124);
            x++;
            while (x < subtree[i].col2)
            {
              printf(" ");
              x++;
            }
            printf("%c", 124);
            x++;
            while (x < subtree[i].col3)
            {
              printf(" ");
              x++;
            }
            printf("%c", 124);
            x++;
          }
          else if (subtree[i].col1 == -1 && subtree[i].col3 == x)
          {
            printf("%c", 124);
            x++;
          }
        }
      }
      printf(" ");
    }
    printf("\n");
  }
}


int main()
{
  float overall_value;        /* the value of the whole expression */
  int p;

  printf("Expression: ");
  gets(inputstring);          /* read arithmetic expression */
  scanString(inputstring);    /* scan input and generate list of terminals */

  terminal_position--;        /* set terminal_position to last terminal in the list */
  subtree_position = 0;
  overall_value = evaluateExpression(0, &p);    /* parse and evaluate whole expression */
                                            /* ('Expression' is start symbol in the CFG) */
  if (terminal_position == 0)               /* if the whole input was read without error... */
    printf("Result: %f\n", overall_value);  /* ... then output result */
  else
  {
    printf("Syntax error\n");               /* otherwise indicate error */
    exit(1);
  }
  printTree();
}
